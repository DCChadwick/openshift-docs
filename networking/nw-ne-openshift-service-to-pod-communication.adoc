// Module included in the following assemblies:
// * understanding-networking.adoc


[id="nw-ne-openshift-service-to-pod-communication_{context}"]
= Service-to-pod communication

Service-to-pod communication ensures that services can reliably route traffic to the appropriate pods. Services are Kubernetes objects that define a logical set of pods and provide a stable endpoint (an IP address and a DNS name) for other components to interact with. Services abstract pod IPs, which can change, and provide a consistent way to access the application components.

Key concepts of service-to-pod communication include:

Endpoints::
Endpoints define the network locations (IP addresses and ports) of the pods that are associated with a service.

Selectors::
Selectors use labels (key-value pairs) to define the criteria for selecting a set of objects, such as pods, that a service should target.

Services::
Services provide a stable IP address and DNS name for a set of pods. This abstraction allows other components to communicate with the service rather than individual pods.

Service Discovery::
Kubernetes services are discoverable via DNS. When a service is created, it is assigned a DNS name, which other pods can use to communicate with it.

* Service Types::
Different service types (ClusterIP, NodePort, and LoadBalancer) dictate how services are exposed within or outside the cluster:

** ClusterIP::
ClusterIP exposes the service on an internal cluster IP. It is the default service type and makes the service only reachable from within the cluster.

** NodePort::
NodePort exposes the service on each Node's IP at a static port, allowing external traffic to access the service.

** LoadBalancer::
LoadBalancer exposes the service externally using a cloud provider's load balancer.

Services use selectors to identify the pods that should receive the traffic. The selectors match labels on the pods to determine which pods are part of the service. Example: A service with the selector `app: myapp` will route traffic to all pods with the label `app: myapp`.

Endpoints are dynamically updated to reflect the current IP addresses of the pods that match the service selector. Kubernetes maintains these endpoints and ensures that the service routes traffic to the correct pods.

In a Kubernetes environment, the communication flow refers to the sequence of steps and interactions that occur when a service in Kubernetes routes traffic to the appropriate pods. The typical communication flow for service-to-pod communication is as follows:

* Service creation::
When you create a service, you define the service type (ClusterIP, NodePort, LoadBalancer), the port on which the service listens, and the selector labels.
 
 [source, yaml]
   apiVersion: v1
   kind: Service
   metadata:
     name: my-service
   spec:
     selector:
       app: myapp
     ports:
       - protocol: TCP
         port: 80
         targetPort: 8080

* DNS Resolution::
Kubernetes assigns a DNS name to the service, which other pods can use to communicate with the service. For example, if the service is named `my-service` in the `default` namespace, its DNS name is `my-service.default.svc.cluster.local`.

* Traffic Routing::
When a pod sends a request to the service’s DNS name, Kubernetes resolves the name to the service’s ClusterIP. The service then routes the traffic to one of the pods that match its selector, using the endpoints.

* Load Balancing::
Services also provide basic load balancing. They distribute incoming traffic across all the pods that match the selector. This ensures that no single pod is overwhelmed with too much traffic.