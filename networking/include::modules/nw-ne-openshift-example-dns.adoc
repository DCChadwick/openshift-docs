// Module included in the following assemblies:
// * understanding-networking.adoc


[id="nw-ne-openshift-example-dns_{context}"]
= Example: DNS use case

Imagine you have a front-end application running in one set of pods and a back-end service running in another set of pods. The front-end application needs to communicate with the back-end service. You create a Kubernetes service for the back-end pods, giving it a stable IP and DNS name. The front-end pods use this DNS name to access the back-end service, regardless of changes to individual pod IP addresses.

By creating a Kubernetes service for the back-end pods, you provide a stable IP and DNS name (`backend-service.default.svc.cluster.local`) that the front-end pods can use to communicate with the back-end service. This setup would ensure that even if individual pod IP addresses change, the communication remains consistent and reliable. To do so, complete the following steps:

1. Create the back-end service. 

a. Deploy the back-end pods:
   
Create a deployment for the back-end application.
   [source, yaml]
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: backend-deployment
     labels:
       app: backend
   spec:
     replicas: 3
     selector:
       matchLabels:
         app: backend
     template:
       metadata:
         labels:
           app: backend
       spec:
         containers:
           - name: backend-container
             image: your-backend-image
             ports:
               - containerPort: 8080

b. Create the Back-End Service:
   
Define a service to expose the back-end pods.
   [source, yaml]
   apiVersion: v1
   kind: Service
   metadata:
     name: backend-service
   spec:
     selector:
       app: backend
     ports:
       - protocol: TCP
         port: 80
         targetPort: 8080

2. Create the front-end deployment. 

Deploy the front-end pods:

Create a deployment for the front-end application.
  [source, yaml]
  apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: frontend-deployment
     labels:
       app: frontend
   spec:
     replicas: 3
     selector:
       matchLabels:
         app: frontend
     template:
       metadata:
         labels:
           app: frontend
       spec:
         containers:
           - name: frontend-container
             image: your-frontend-image
             ports:
               - containerPort: 80

3. Configure front-end to communicate with back-end. 

Use the DNS name of the back-end service:

In your front-end application code, use the DNS name of the back-end service to send requests. For example, if your front-end application needs to fetch data from the back-end, you might have code like this:
  [source, JavaScript]
  fetch('http://backend-service.default.svc.cluster.local/api/data')
     .then(response => response.json())
     .then(data => console.log(data));
